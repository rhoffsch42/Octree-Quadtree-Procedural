[
    {
        "source": "https://www.reddit.com/r/VoxelGameDev/comments/13qsr80/comment/jm7x2x7/"
    },
    {
        "Philip_MOD_DEV": " Hello, I been working on a voxel for quite a while and I came across this problem about on what is the best way for server a client communication. Recently I been looking up more information about the RMI in java, and basically, I am trying to figure on how to have a client send a request to the server asking for chunk updates and player position updates. So, after when the server received a connection from the client it sends back a response with the updated chunk information. That's the goal.  Right now, basically I only am using DatagramSockets and DatagramPackets, but they seem like a hassle to figure out on how to send data back and forth to the server and the client without have a bind address exception thrown.  Anyways, I was just wondering about if there's a simple way on during this process, but it seems like the RMI you have to run a command \"start rmiregistry\" in order for it to work properly. That's not really on what I want though. You see when a user downloads my voxel engine, I want them to make it that they can port LAN worlds as well with servers very easily. So hopefully if anyone could help with the same problem that would be great"
    },
    {
        "schemax_": "In my opinion, RMI is questionable for an application like this, because there is overhead in how java serializes classes. It could be mitigated, but doing so might just eliminate the main advantage of RMI (ease of use).\n\nUDP could be used, but you will run into the problem of having to implement your own validation, congestion control, packet loss reaction, etc, which might in the end just lead to reimplementing what TCP already provides, but on the software layer, which will make it slower than just using TCP outright. It really depends on your use cases. In my experience, UDP only really shines when you really don't care about some packages being lost. You can probably get away with only implementing part of TCP's functionality, but it's a bit of a tradeoff always. The best way is to make your network system in a way where any base protocol can be used, and you would be able to switch between implementation that use TCP or UDP so you can actually test which one is more efficient for your usecase.\n\nIn the end, you will not be able to get around learning low level communication techniques, and implementing a protocol by yourself. There are some solutions in libraries, but using them without understanding how networking works might lead to regret later.\n\nMy systems usually are based on a simple structures that build up to something complex. I send leading bytes indicating the type of the packet that follows, then the amount of bytes the packet is, and then the packet itself. Upon registering the connection you always know who sent a packet, which will determine how it is processed on the other side.\n\nThe system must of course be threaded, which is fairly easy, but does come with some overhead for larger numbers of clients because of unnecessary operations. You can use java's SocketIO to eliminate that problem, but it is slightly more complicated to handle. However, there are some great tutorials out there for all that.\n\nA packet can contain any data, from simple vectors to nested packets. For any data, the receiver either already knows the size (if it's a fixed data structure like a vector), or the sender transmits the size beforehand (for lists or other more dynamic structures).\n\nOther protocols often use \"end of data\" symbols, but I personally am not a fan of that, as it can to lead to some really messy situations in case of bugs. Not that initial size transmittal couldn't also do that (I remember a bug where data was shifted so the size data was suddenly different bytes which lead to the server expecting terabytes of data. Of course things like these are easy to account for by setting limites to expected data)\n\nAt the same time, I implemented a serializable version of all data and classes that need to be sent. They are all built upon each other. So a serializable class can contain other serializable classes like vectors, floats, anything.\n\nYou can use attributes or other techniques to then use reflection to automatically create networkable representation of your classes, so you can be sure that any data is exactly the same on both ends, if they run the same code. For this reason it's very recommended to detach your networking into a library that then both client and server can use.\n\nFor a chunk system, it is built on top of that protocol. A client sends its position to the server and the chunk system keeps a list of which chunks have already been sent and updates which chunks are necessary to be sent to the client from that position. \n\nBecause you shouldn't really send all chunks in one go, it should work more like a finite state machine, where the chunk request process has different states. This way, the server has time to load in missing chunks into its own memory from disk without stalling for other users.\n\nI know what I wrote isn't really much to help you immediately, but I hope it gives you at least some small pointers."
    },
    {
        "Philip_MOD_DEV": "Oh wow that's A lot of information that I will definitely use, thank you so much \ud83d\ude42"
    },
    {
        "Philip_MOD_DEV": "I have a little problem regarding about on when the client receives the chunk data, or the server receive it.\nSo basically after the client sends the chunk data to the server, it sends back the right chunk with the specific coordinates, but the problem is that on when the server tries to send the data back to it, it throws an error saying that the client is unavailable to receive the information.\n\nSo my basic setup is that the workers thread on the client generated the chunks in x, z. The chunks created is based off of the render distance that is first assign in the settings. Thus, every frame the game will check if there's any loaded Chunks in the hashtable at those coordinates, if there is then it will it will continue in the loop, but if there not ,then it will send a request to the server in a form call a ClientRequestPacket class.\n\nThis class holds the necessary data that is used to tell the server on what chunk it needs and the client address to send the chunk back to. Please note that the Server and the client are both running on two threads. So my game has a total of three threads running with the server on, and two threads running with the server off. This setting is toggle by the user on when they want to port world to multiplayer.\n\nOnce the client sends the server a request, it listens for a response every iteration to create the chunks as well including send a server another request. This is where I am confused with, I don't know I should have the client wait or keep sending a request, but all I know for right now, is that something is not allowing the server and the client to receive the new chunk information back to the client.l mean like the client sends the request, and the server receives it, but the client never gets the updated chunks.\n\nAlso on the single player game play, I don't know if it's wise to have three threads running at once for a not so optimize voxel engine that have, like for example when I implement the voxel placement functionally, I noticed that it takes couple of seconds to update the chunk. I don't know any other way to optimize this process but maybe hopefully someone could explain. Plus being that this placement only works in positive x, z coordinates, which is weird."
    },
    {
        "schemax_": "So for the question about errors, it seems to be an error in your setup. The way Java handles networking over TCP is with the Socket class.\n\nYou will probably have to introduce a few more threads for proper handling.\n\nSo at the top you will have a listener thread. This one is not very expensive as it is blocking most of the time. This is the thread that essentially just listens for new connections. This is done using the ServerSocket.accept() method. The thread will block on the accept until a new connection is made. A new socket connection is returned as soon as a connection from a client has been made.\n\nYou should then take that Socket instance, and hand it off to a processor thread. You can either do one processor per client, or have one thread process all client data sequentially.\n\nHowever, you might have to further split up the work in threads to avoid possible bottlenecks. You don't want your whole program to stall because a client is in a bad state (timing out). So I recommend a thread per client to receive and send data, but not do any actual processing of data. These threads simple have a queue of your packages for both sending and receiving, and all those threads do is block until there is data in those queues. There should be some good tutorials on blocking and waking up threads, since that is not entirely intuitive as you will need the synchronized keyword in some areas (though not everywhere to actually make use of threading).\n\nSo you will have:\n\n* server listener\n* server main thread\n\nfor each client on server side:\n\n* server sender\n* server receiver\n\nFor each client\n\n*  client main thread\n*  client sender\n*  client receiver\n\n(optionally processor threads for serialization)\n\nThere you should have one thread to process the data. This could technically also be done in the main thread, but since this thread mostly just serializes and deserializes data, it can run parallel (turning your data into bytes, and turing bytes into your data structures). For performance you should build a system for object pools on top of that to avoid new memory allocations e.g. a chunk request can be reused for the next request. The actual processing of the finished packages should of course happen in synch with the main thread (or on the main thread which is easier).\n\nTo get this working, it's probably best to setup a little side program to test basic sending on receiving, which should help you figure out why the error is happening. If you can send/receive text, you can send/receive anything. There might be some options you have to set on the sockets etc to get it to work properly, but normally they should work out of the box.\n\nA common misconception is that the server needs to connect to the client after the client connected to the server. This is not the case. One socket can be used for both sending and receiving data using its inputStream and outputStream (flushing those will send the data). Be sure to always use BufferedStreams for performance.\n\n\nNow, for the chunk request/answer. A client should only ever request the same chunk once. Since on TCP data is guaranteed to always arrive, there is no need to worry about lost packages. However, the client must keep track of which chunks are currently requested. It doesn't need to actively check if there is an answer to your requests. Looking up the request should be done only at the time the server sends an answer. However, a client should be able to send multiple requests for different chunks. They would just all be queued up for the server to process and send back. Be sure to implement it in a way that waiting for a chunk will not in any way block the main thread from running. \n\nTo optimize you can build a chunk cache that acts exactly like the server. It takes requests and answers them by checking cached data either in memory or on disk, and if there is a missing chunk, it will in turn do the same to the actual server. However, it's a bit more complicated with multiple clients as it's possible for a chunk to change and the cache having the old version of a chunk, so the cache system has to at least request a timestamp it can compare with its own data on when it was last changed.\n\nI suspect that the issue with it taking seconds is also due to the setup. You might have to manually flush data out of your sending socket each tick. I also recommend running the sending/receiving thread at a lower speed than your framerate. Since you're probably not planning on doing a high precision FPS you can probably get away with as few as like 16 updates/sec.\n\nFor single player, I recommend doing exactly what you did in using a local network communicating between server and one client. Yes, this takes a bit more memory, but otherwise you will be doing the same work twice, and you will quickly end up with a mess when things get handled in two ways. One of the main reasons why most games that announce \"We will add multiplayer later\" never do that, is because it becomes incredibly difficult to do after the fact.\n\nGames have been using this method to great success for a long time, one of the earlier examples I can think of is Diablo 2 for example.\n\nIn my experience, network programming is one of the hardest things to do correctly, as you will have to have good understanding of the lower and upper layers, as well as multi threading and data efficiency, and probably takes anyone at least a few iterations to get something usable.\n\nAgain, my recommendation is to build the networking system separately first (with the requirements of your game in mind), and then integrate it into your system. This way, you can test in small scale in a more controlled environment. You can even setup case testing that way if you so desire. Case testing is very useful in this case to ensure that all your basic functionality is covered.\n\nA well setup network system is incredibly useful, and the nice thing is you can use it over and over for any project, and build and expand on it."
    },
    {
        "Philip_MOD_DEV": "Ok, thank you for the information.\nAlso can I use ForkJoinTask and ForkJoinPool ,for this type of job? Hopefully this will help on when it comes to fast execution time. Also can I use SocketChanels? Because when I experience with working on them I keep getting error saying that the data from the client is null, even though I just send the data to the server while it is connected to it. But for some reason the server receives the data as a zero value in the byte array."
    },
    {
        "schemax_": "Threads do have some overhead, but you don't really have to worry too much about it unless you get into a lot of them. Most of the overhead in threads also is very avoidable. Java already has systems like thread pools for if you need temporary threads. Essentially, it will eliminate the overhead of spawning new threads.\n\nThe rest is minor overhead from monitoring and waking up / blocking / context switch threads.\n\nIn terms of scalability, once your thread solution works, you can try and implement the same system based on java's NIO (New IO) system.\n\nIf you did your protocol well enough, it's just a matter of replacing the data handling, but you can of course directly start implementing that. It's a bit more complicated and a lot harder to figure out bugs on however, so I recommend doing a thread based system first and then try NIO.\n\nEssentially, the difference in systems is that in NIO you get one stream of data arriving. This stream is chunks of data from all clients. This data can, but doesn't have to be full chunks of packages you send.\n\nThis means if you send 1000 bytes from 3 clients, you can get 3 bytes of client A, then 231 bytes of client B, then 214 bytes from client A again, then 24 bytes of client C, and so forth.\n\nSo keeping buffers and putting the streams back together to form full packages is on you. Since everything is one big chunk now, it introduces some more areas of failure if there are bugs in your base implementation, as data can easily mix. You will also have to do some efficient memory management, clearing and reusing buffers, as well as thread safety in communicating with your main thread, as this system should still run in parallel with your game logic.\n\nHowever, the main advantage is that it is a lot more performant and also scalable, as the sender/receiver can run on a single thread for ALL clients together. I've done projects that can handle over 1000 clients easily (though of course for a voxel game it would still struggle considering the required bandwidth).\n\nThere are some good tutorials out there for NIO, but again, doing it thread based first is definitely the easier way.\n\nhttps://www.baeldung.com/java-nio-selector\n\n\nAll in all, Minecraft using only a few threads is to its detriment, as most CPU have multiple cores now, so having everything in one thread will not utilize the CPU fully. But making something single threaded to multi threaded after the fact is incredibly hard, as its a different more complicated design. In the case of minecraft, the base code simply wasn't made to be multithreaded a lot. At least to my knowledge.\n\nWell used threads speed things up, and not slow them down. You want to use threads when possible and where it makes sense (but it required experience to know which ones do), though of course you can use them in the wrong areas, and overdo it. Also, bad implementation of those threads also can make the whole thing slow down (too much synchronization for example)."
    },
    {
        "Philip_MOD_DEV": "Ok, thank you so much for the information that was given, yes like you said, I will do a copy of my voxel project and use it as a test template for my networking setup. That way I can probably figure out a more understanding of the server side and clients trying to connect to it, as well I don't have to worry about breaking something in the code structure, also \nwould you prefer this, or just go from a something small from scratch? \n\nAlso by the way, would it be best that the single player or local host have at less three threads running. One for chunk updates, the other for  \nrendering the mesh (main thread) and lastly the local server for generating the chunk data? Reason that I am asking this is because I kinda concerned about having too much threads running for my application because I don't know how true this is, but doesn't Minecraft run on one or two threads, and threads are kinda costly for CPU time? I am basically trying to keep performance as well with having efficiency for the users who have low end PC's, as I plan to publish the game somewhere in the future."
    },
    {
        "Philip_MOD_DEV": "Hello sorry for the reply, I have a problem regarding about on who SocketsChanels and ServerSocketChanels function for my Voxel Game Engine. So on a side not I made a project for testing with my networking before I implement the functionally to\nmy game. So the problem that I am currently facing is that the client send a request to the server in a form of a compressed data inside of a ByteBuffer. This data is a serialized class called ClientPacket on which holds the information on what the server needs to process to back to the client. But the problem is that when the data gets wrap up into a ByteBuffer, I send the Buffer using the SocketChanel's write(), and once the server receives the connection from the client using the accept(), it proceed to make an instance of the SocketChanel that is currently\nconnected to the server. So when the server reads the Data from the SocketChanel it store it into another ByteBuffer using the read(). Once the data is decompressed and it read it saying that its null or 0 in the byte array.\nThe image shows an example on what happens. I don't know why this is happen for me, but I hope someone can explain more."
    }
]